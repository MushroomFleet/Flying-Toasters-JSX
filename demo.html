<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flying Toasters - SVGA Wireframe Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #000008;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }
    
    #canvas {
      display: block;
    }
    
    .overlay {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #0088aa;
      font-size: 12px;
      opacity: 0.6;
      text-shadow: 0 0 10px #00aaff;
      pointer-events: none;
    }
    
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 20, 40, 0.8);
      border: 1px solid #0066aa;
      padding: 15px;
      color: #00ccff;
      font-size: 12px;
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(0, 100, 200, 0.3);
    }
    
    .controls h3 {
      margin-bottom: 10px;
      color: #00ffff;
      text-shadow: 0 0 10px #00aaff;
    }
    
    .controls label {
      display: block;
      margin: 8px 0;
      cursor: pointer;
    }
    
    .controls input[type="range"] {
      width: 120px;
      margin-left: 10px;
      vertical-align: middle;
    }
    
    .controls input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .controls button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #004466;
      border: 1px solid #0088cc;
      color: #00ffff;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s;
    }
    
    .controls button:hover {
      background: #006688;
      box-shadow: 0 0 10px #00aaff;
    }
    
    .info {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 20, 40, 0.8);
      border: 1px solid #0066aa;
      padding: 10px 15px;
      color: #00ccff;
      font-size: 11px;
      border-radius: 4px;
    }
    
    .info span {
      color: #00ffaa;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="overlay">
    FLYING TOASTERS • SVGA WIREFRAME • 640×480×256
  </div>
  
  <div class="controls">
    <h3>⚙️ DEMO CONTROLS</h3>
    <label>
      Toasters: <span id="toasterCountDisplay">8</span>
      <input type="range" id="toasterCount" min="1" max="20" value="8">
    </label>
    <label>
      Wing Speed: <span id="wingSpeedDisplay">1.0</span>x
      <input type="range" id="wingSpeed" min="0.5" max="3" step="0.1" value="1">
    </label>
    <label>
      Flight Speed: <span id="flightSpeedDisplay">1.0</span>x
      <input type="range" id="flightSpeed" min="0.5" max="3" step="0.1" value="1">
    </label>
    <label>
      <input type="checkbox" id="scanlines" checked>
      CRT Scanlines
    </label>
    <label>
      <input type="checkbox" id="glow" checked>
      Vertex Glow
    </label>
    <label>
      <input type="checkbox" id="trails" checked>
      Motion Trails
    </label>
    <button onclick="resetToasters()">Reset Toasters</button>
  </div>
  
  <div class="info">
    FPS: <span id="fps">60</span> | 
    Vertices: <span id="vertices">0</span> | 
    Edges: <span id="edges">0</span>
  </div>

  <script>
    // ============================================
    // FLYING TOASTERS - SVGA WIREFRAME RENDERER
    // ============================================
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Configuration
    let config = {
      toasterCount: 8,
      wingSpeedMultiplier: 1.0,
      flightSpeedMultiplier: 1.0,
      scanlines: true,
      glow: true,
      trails: true
    };
    
    // Stats
    let stats = { fps: 0, vertices: 0, edges: 0 };
    let lastTime = performance.now();
    let frameCount = 0;
    
    // Resize handler
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();
    
    // ============================================
    // 3D MATH UTILITIES
    // ============================================
    
    const vec3 = {
      add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]],
      sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]],
      scale: (v, s) => [v[0] * s, v[1] * s, v[2] * s],
      dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
      cross: (a, b) => [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ],
      normalize: (v) => {
        const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        return len > 0 ? [v[0] / len, v[1] / len, v[2] / len] : [0, 0, 0];
      }
    };
    
    // Rotation functions
    const rotateX = (v, angle) => {
      const c = Math.cos(angle), s = Math.sin(angle);
      return [v[0], v[1] * c - v[2] * s, v[1] * s + v[2] * c];
    };
    
    const rotateY = (v, angle) => {
      const c = Math.cos(angle), s = Math.sin(angle);
      return [v[0] * c + v[2] * s, v[1], -v[0] * s + v[2] * c];
    };
    
    const rotateZ = (v, angle) => {
      const c = Math.cos(angle), s = Math.sin(angle);
      return [v[0] * c - v[1] * s, v[0] * s + v[1] * c, v[2]];
    };
    
    // ============================================
    // 3D MODELS
    // ============================================
    
    function createToasterModel() {
      return {
        vertices: [
          // Front face
          [-1, -0.6, 0.5], [1, -0.6, 0.5], [1, 0.6, 0.5], [-1, 0.6, 0.5],
          // Back face  
          [-1, -0.6, -0.5], [1, -0.6, -0.5], [1, 0.6, -0.5], [-1, 0.6, -0.5],
          // Bread slots (top)
          [-0.7, 0.6, 0.3], [-0.3, 0.6, 0.3], [-0.3, 0.6, -0.3], [-0.7, 0.6, -0.3],
          [0.3, 0.6, 0.3], [0.7, 0.6, 0.3], [0.7, 0.6, -0.3], [0.3, 0.6, -0.3],
          // Lever
          [0.9, 0.2, 0.51], [1.1, 0.2, 0.51], [1.1, 0.5, 0.51], [0.9, 0.5, 0.51],
        ],
        edges: [
          // Front face
          [0, 1], [1, 2], [2, 3], [3, 0],
          // Back face
          [4, 5], [5, 6], [6, 7], [7, 4],
          // Connecting edges
          [0, 4], [1, 5], [2, 6], [3, 7],
          // Slot 1
          [8, 9], [9, 10], [10, 11], [11, 8],
          // Slot 2
          [12, 13], [13, 14], [14, 15], [15, 12],
          // Lever
          [16, 17], [17, 18], [18, 19], [19, 16],
        ]
      };
    }
    
    function createWingModel(side) {
      const mirror = side === 'left' ? -1 : 1;
      const vertices = [];
      const edges = [];
      
      const baseX = mirror * 1.0;
      const wingLength = 1.8;
      const wingSegments = 5;
      
      for (let i = 0; i <= wingSegments; i++) {
        const t = i / wingSegments;
        const x = baseX + mirror * t * wingLength;
        const featherWidth = 0.4 * (1 - t * 0.5);
        
        vertices.push([x, 0.3, featherWidth]);
        vertices.push([x, 0.3, -featherWidth]);
        vertices.push([x, 0.1, featherWidth * 0.7]);
        vertices.push([x, 0.1, -featherWidth * 0.7]);
      }
      
      for (let i = 0; i < wingSegments; i++) {
        const base = i * 4;
        edges.push([base, base + 1]);
        edges.push([base + 2, base + 3]);
        edges.push([base, base + 2]);
        edges.push([base + 1, base + 3]);
        edges.push([base, base + 4]);
        edges.push([base + 1, base + 5]);
        edges.push([base + 2, base + 6]);
        edges.push([base + 3, base + 7]);
        edges.push([base, base + 5]);
        edges.push([base + 1, base + 4]);
      }
      
      const last = wingSegments * 4;
      edges.push([last, last + 1]);
      edges.push([last + 2, last + 3]);
      edges.push([last, last + 2]);
      edges.push([last + 1, last + 3]);
      
      return { vertices, edges, side };
    }
    
    // ============================================
    // FLYING TOASTER ENTITY
    // ============================================
    
    class FlyingToaster {
      constructor(initial = false) {
        this.reset(initial);
        this.body = createToasterModel();
        this.leftWing = createWingModel('left');
        this.rightWing = createWingModel('right');
      }
      
      reset(initial = false) {
        if (initial) {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
        } else {
          this.x = canvas.width + 100 + Math.random() * 200;
          this.y = -100 - Math.random() * 200;
        }
        this.z = 200 + Math.random() * 400;
        this.speed = 1.5 + Math.random() * 1.5;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.02;
        this.wingPhase = Math.random() * Math.PI * 2;
        this.wingSpeed = 0.15 + Math.random() * 0.05;
        this.rotY = -0.3 + Math.random() * 0.2;
        this.rotX = 0.2 + Math.random() * 0.1;
        this.scale = 40 + Math.random() * 30;
      }
      
      update() {
        const speedMult = config.flightSpeedMultiplier;
        this.x -= this.speed * 2 * speedMult;
        this.y += this.speed * 1.5 * speedMult;
        this.wobble += this.wobbleSpeed * speedMult;
        this.wingPhase += this.wingSpeed * config.wingSpeedMultiplier;
        
        if (this.x < -200 || this.y > canvas.height + 200) {
          this.reset();
        }
      }
      
      getWingAngle() {
        return Math.sin(this.wingPhase) * 0.5;
      }
    }
    
    // ============================================
    // RENDERING
    // ============================================
    
    const lightDir = vec3.normalize([0.5, 0.7, 0.5]);
    
    function computeVertexColor(vertex, normal) {
      const baseColor = { r: 0, g: 200, b: 255 };
      const highlightColor = { r: 255, g: 100, b: 255 };
      
      const ndotl = Math.max(0, vec3.dot(normal, lightDir));
      const ambient = 0.3;
      const diffuse = 0.7 * ndotl;
      const intensity = ambient + diffuse;
      
      const heightBlend = (vertex[1] + 1) / 2;
      
      return {
        r: Math.floor(baseColor.r * (1 - heightBlend) + highlightColor.r * heightBlend) * intensity,
        g: Math.floor(baseColor.g * (1 - heightBlend) + highlightColor.g * heightBlend) * intensity,
        b: Math.floor(baseColor.b * (1 - heightBlend) + highlightColor.b * heightBlend) * intensity
      };
    }
    
    function project(vertex, centerX, centerY, fov = 400) {
      const z = vertex[2] + fov;
      if (z <= 0) return null;
      const scale = fov / z;
      return {
        x: centerX + vertex[0] * scale,
        y: centerY - vertex[1] * scale,
        z: z,
        scale: scale
      };
    }
    
    function drawWireframeLine(p1, p2, color1, color2) {
      if (!p1 || !p2) return;
      
      const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
      gradient.addColorStop(0, `rgb(${color1.r}, ${color1.g}, ${color1.b})`);
      gradient.addColorStop(1, `rgb(${color2.r}, ${color2.g}, ${color2.b})`);
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = Math.max(1, (p1.scale + p2.scale) * 0.5);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }
    
    // ============================================
    // TOASTER MANAGEMENT
    // ============================================
    
    let toasters = [];
    
    function initToasters() {
      toasters = [];
      for (let i = 0; i < config.toasterCount; i++) {
        toasters.push(new FlyingToaster(true));
      }
    }
    
    function updateToasterCount() {
      while (toasters.length < config.toasterCount) {
        toasters.push(new FlyingToaster(true));
      }
      while (toasters.length > config.toasterCount) {
        toasters.pop();
      }
    }
    
    function resetToasters() {
      initToasters();
    }
    
    // ============================================
    // MAIN RENDER LOOP
    // ============================================
    
    function render() {
      // Clear with trail effect
      if (config.trails) {
        ctx.fillStyle = 'rgba(0, 0, 10, 0.3)';
      } else {
        ctx.fillStyle = '#000008';
      }
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Update stats
      stats.vertices = 0;
      stats.edges = 0;
      
      // Sort by Z depth
      const sortedToasters = [...toasters].sort((a, b) => b.z - a.z);
      
      for (const toaster of sortedToasters) {
        toaster.update();
        
        const centerX = toaster.x;
        const centerY = toaster.y;
        const wingAngle = toaster.getWingAngle();
        
        const transformVertex = (v) => {
          let transformed = vec3.scale(v, toaster.scale);
          transformed = rotateX(transformed, toaster.rotX);
          transformed = rotateY(transformed, toaster.rotY);
          transformed[2] += toaster.z;
          return transformed;
        };
        
        const transformWingVertex = (v, wing) => {
          let transformed = [...v];
          const flapAngle = wing.side === 'left' ? -wingAngle : wingAngle;
          const pivotX = wing.side === 'left' ? -1.0 : 1.0;
          transformed[0] -= pivotX;
          transformed = rotateZ(transformed, flapAngle);
          transformed[0] += pivotX;
          transformed = vec3.scale(transformed, toaster.scale);
          transformed = rotateX(transformed, toaster.rotX);
          transformed = rotateY(transformed, toaster.rotY);
          transformed[2] += toaster.z;
          return transformed;
        };
        
        // Render body
        const bodyVertices = toaster.body.vertices.map(transformVertex);
        const bodyProjected = bodyVertices.map(v => project(v, centerX, centerY));
        const bodyColors = bodyVertices.map(v => {
          const normal = vec3.normalize([v[0] * 0.3, v[1], v[2] * 0.5]);
          return computeVertexColor(v, normal);
        });
        
        stats.vertices += bodyVertices.length;
        stats.edges += toaster.body.edges.length;
        
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        for (const edge of toaster.body.edges) {
          drawWireframeLine(
            bodyProjected[edge[0]],
            bodyProjected[edge[1]],
            bodyColors[edge[0]],
            bodyColors[edge[1]]
          );
        }
        
        // Render wings
        for (const wing of [toaster.leftWing, toaster.rightWing]) {
          const wingVertices = wing.vertices.map(v => transformWingVertex(v, wing));
          const wingProjected = wingVertices.map(v => project(v, centerX, centerY));
          const wingColors = wingVertices.map(v => {
            const normal = vec3.normalize([0, 1, 0]);
            const base = computeVertexColor(v, normal);
            return {
              r: Math.min(255, base.r + 100),
              g: Math.min(255, base.g + 50),
              b: base.b
            };
          });
          
          stats.vertices += wingVertices.length;
          stats.edges += wing.edges.length;
          
          for (const edge of wing.edges) {
            if (wingProjected[edge[0]] && wingProjected[edge[1]]) {
              drawWireframeLine(
                wingProjected[edge[0]],
                wingProjected[edge[1]],
                wingColors[edge[0]],
                wingColors[edge[1]]
              );
            }
          }
        }
        
        // Vertex glow
        if (config.glow) {
          for (let i = 0; i < 4; i++) {
            const p = bodyProjected[i];
            if (p && p.z > 0) {
              const glowSize = 3 * p.scale;
              const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize);
              gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
              gradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.3)');
              gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }
      
      // Scanlines
      if (config.scanlines) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
        for (let y = 0; y < canvas.height; y += 3) {
          ctx.fillRect(0, y, canvas.width, 1);
        }
      }
      
      // FPS calculation
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        stats.fps = frameCount;
        frameCount = 0;
        lastTime = now;
        document.getElementById('fps').textContent = stats.fps;
        document.getElementById('vertices').textContent = stats.vertices;
        document.getElementById('edges').textContent = stats.edges;
      }
      
      requestAnimationFrame(render);
    }
    
    // ============================================
    // UI CONTROLS
    // ============================================
    
    document.getElementById('toasterCount').addEventListener('input', (e) => {
      config.toasterCount = parseInt(e.target.value);
      document.getElementById('toasterCountDisplay').textContent = config.toasterCount;
      updateToasterCount();
    });
    
    document.getElementById('wingSpeed').addEventListener('input', (e) => {
      config.wingSpeedMultiplier = parseFloat(e.target.value);
      document.getElementById('wingSpeedDisplay').textContent = config.wingSpeedMultiplier.toFixed(1);
    });
    
    document.getElementById('flightSpeed').addEventListener('input', (e) => {
      config.flightSpeedMultiplier = parseFloat(e.target.value);
      document.getElementById('flightSpeedDisplay').textContent = config.flightSpeedMultiplier.toFixed(1);
    });
    
    document.getElementById('scanlines').addEventListener('change', (e) => {
      config.scanlines = e.target.checked;
    });
    
    document.getElementById('glow').addEventListener('change', (e) => {
      config.glow = e.target.checked;
    });
    
    document.getElementById('trails').addEventListener('change', (e) => {
      config.trails = e.target.checked;
    });
    
    // ============================================
    // INITIALIZATION
    // ============================================
    
    initToasters();
    render();
  </script>
</body>
</html>
